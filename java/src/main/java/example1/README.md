<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [Simple Java example](#simple-java-example)
- [Separation of concerns](#separation-of-concerns)
- [Using a Component](#using-a-component)
- [Creating a Component](#creating-a-component)
  - [Dagger 2 field injection limitations](#dagger-2-field-injection-limitations)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# Simple Java example

This is an extremely basic example to get started with Dagger 2. The `Main` class simply logs a
message to the console. However, it does not create a `Log` object itself, and relies on Dagger 2
to provide an object that implements this interface.

The `Log` interface is just 1 method.

```java
public interface Log {

    void log(String message);
}
```
# Separation of concerns

The idea here is that there may be many different implementations of this interface, ones that
simply write to console.log, and others that might write to the network, or the filesystem, and
so forth.

Only the console logging implementation is provided in `LogImpl`, but the `Main` class is unaware
of this.

# Using a Component

The `Main` class imply asks Dagger 2 for a `Log` object.

```java
LogComponent logComponent = DaggerLogComponent
        .builder()
        .logModule(new LogModule())
        .build();
```

# Creating a Component

`DaggerLogComponent` is a class that's generated by Dagger 2, that provides the `Log` object to the
`Main` class. The `@Component` annotation is used to tell Dagger 2 to generate this class, as shown
below.

```java
@Singleton
@Component(modules = {LogModule.class})
public interface LogComponent {
    Log providesLog();
    void injectDepsIntoFieldsOf(Main main);
}
```

## Dagger 2 field injection limitations

Notice, the `injectDepsIntoFieldsOf(Main)` function is provided as well. This is because the `Main`
class actually needs the `Log` object injected into a **field** of its. And since Dagger 2 can't
automatically inject into fields that are marked `@Inject`, this method has to be called by `Main`
in order for it to allow Dagger 2 to inject an object into the field `logger` as shown below. This
would not be the case if `@Inject` was used on a constructor or method (which Dagger 2 would be
able to handle automatically).

```java
public class Main{
    @Inject
    public Log logger;  
    
    public Main() {
        LogComponent logComponent = DaggerLogComponent.create();
        logComponent.injectDepsIntoFieldsOf(this);
    }
}
```

This field injection limitation and workaround patterns shows up in Android (since Android 
system components aren't created via constructors).

The rest of this example is very straightforwards.

The `LogModule` class is tagged with `@Module` and it has the responsibility of providing
(`@Provides`) an implementation of the `Log` interface. And this is where Dagger 2 is told
how to provide an implementation of Log. The consumers of `Log` are totally unaware of the
underlying implementation (which is as it should be). This is the only place where you see
a mapping from the interface to it's underlying implementation! This is great as the underlying
implementation can be swapped out at any time, eg, for testing.
